# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v0_PGKR2jdmKIqtbInA86PvPsfj7S8v9
"""

# -*- coding: utf-8 -*-

# imports and utilities
import streamlit as st
import pandas as pd
import numpy as np
from scipy.signal import butter, filtfilt, find_peaks
from scipy.stats import zscore
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import io

def butter_lowpass_filter(data, cutoff, fs, order):
    """
    Apply a Butterworth low-pass filter to the input data.
    """
    nyquist = 0.5 * fs
    normal_cutoff = cutoff / nyquist
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    filtered_data = filtfilt(b, a, data)
    return filtered_data

def corner_detection(data, column_name):
    zscore_threshold = 1
    data['z-axis_normalized'] = (data[column_name] - data[column_name].min()) / (data[column_name].max() - data[column_name].min())
    data['z-axis_normalized_rate_of_change'] = data['z-axis_normalized'].diff()
    data['z-axis_normalized_zscore'] = zscore(data['z-axis_normalized'])

    positive_potential_peaks_normalized = data[(data['z-axis_normalized_rate_of_change'].abs() > data['z-axis_normalized_rate_of_change'].quantile(0.7)) &
                                            (data['z-axis_normalized_zscore'] > zscore_threshold) &
                                            (data['z-axis_normalized'] > 0)]['z-axis_normalized']

    filtered_peaks_indices_normalized = []
    last_peak_index = 0
    min_distance_between_peaks = 700

    for index in positive_potential_peaks_normalized.index:
        if index - last_peak_index >= min_distance_between_peaks:
            filtered_peaks_indices_normalized.append(index)
            last_peak_index = index

    refined_peaks_normalized = data.loc[filtered_peaks_indices_normalized, column_name]
    return refined_peaks_normalized

def zero_crossing(df, column_name):
    df['Shifted'] = df[column_name].shift(1)
    df['Value'] = df[column_name]
    df['Neg_to_Pos'] = (df['Value'] > 0) & (df['Shifted'] < 0)
    df['Pos_to_Neg'] = (df['Value'] < 0) & (df['Shifted'] > 0)
    neg_to_pos_df = df[df['Neg_to_Pos']].copy()
    pos_to_neg_df = df[df['Pos_to_Neg']].copy()
    result = pd.concat([pos_to_neg_df, neg_to_pos_df])
    result = result.sort_index()
    result.rename(columns={'Neg_to_Pos': 'corner_entrance'}, inplace=True)
    result.rename(columns={'Pos_to_Neg': 'corner_exit'}, inplace=True)
    return result

def find_entrance_exit(peaks, entrance_exit):
    df = entrance_exit
    start_idx = min(peaks.index)
    end_idx = max(peaks.index)
    selected_df = df.loc[start_idx:end_idx]
    all_indices = df.index.tolist()
    selected_indices = selected_df.index.tolist()
    before_after_indices = []

    for idx in selected_indices:
        idx_pos = all_indices.index(idx)
        if idx_pos > 0:
            before_after_indices.append(all_indices[idx_pos - 1])
        before_after_indices.append(idx)
        if idx_pos < len(all_indices) - 1:
            before_after_indices.append(all_indices[idx_pos + 1])
    final_indices = sorted(set(before_after_indices))
    final_selection = df.loc[final_indices]
    return final_selection

def apply_filter_corner(data, column_name, cutoff):
    fs = 200
    order = 1
    filtered_signal = butter_lowpass_filter(data[column_name], cutoff, fs, order)
    result = data.copy()
    result[column_name] = filtered_signal
    return result

def push_detection(data, column_name, sampling_rate):
    peaks, _ = find_peaks(data[column_name], prominence=0.5, distance=sampling_rate/4)
    return peaks

def apply_filter_push(data, column_name, sampling_rate):
    cutoff = 5
    fs = sampling_rate
    order = 5
    filtered_signal = butter_lowpass_filter(data[column_name], cutoff, fs, order)
    data['filtered_signal'] = filtered_signal
    return data

def entrance_exit_function(df_source):
    data = apply_filter_corner(df_source.copy(),'Angle Y(°)',0.5)
    peaks = corner_detection(df_source,'Angle Y(°)')
    zero_cross = zero_crossing(data,'Angle Y(°)')
    entrance_exit = find_entrance_exit(peaks, zero_cross)
    return entrance_exit

def straight_push_index(entrance_exit):
    df = entrance_exit
    exit_indices = df.index[df['corner_exit']].tolist()
    entrance_indices = df.index[df['corner_entrance']].tolist()
    pairs = []
    for i in range(len(exit_indices)-1):
        current_exit_idx = exit_indices[i]
        for j in range(len(entrance_indices)):
            if entrance_indices[j] > current_exit_idx:
                pairs.append((current_exit_idx, entrance_indices[j]))
                break
    return pairs

def combined_frontal_acceleration(df):
    df['combined acceleration'] = (df['Acceleration Z(g)']**2+df['Acceleration Y(g)']**2+df['Acceleration X(g)']**2)**0.5
    return df

def process_and_visualize(global_df):
    global_df = combined_frontal_acceleration(global_df)
    entrance_exit = entrance_exit_function(global_df)

    df = entrance_exit
    closest_pairs = []
    for entrance_index, entrance_row in df[df['corner_entrance']].iterrows():
        min_diff = np.inf
        closest_exit_index = None
        for exit_index, exit_row in df[df.index > entrance_index].iterrows():
            if exit_row['corner_exit']:
                diff = exit_index - entrance_index
                if diff < min_diff and diff <= 2000:
                    min_diff = diff
                    closest_exit_index = exit_index
        if closest_exit_index is not None:
            closest_pairs.append([entrance_index, closest_exit_index, min_diff,'Corner'])
    closest_pairs_df_corner = pd.DataFrame(closest_pairs, columns=['Start Index', 'End Index', 'Index Difference','Type'])

    closest_pairs = []
    for exit_index, exit_row in df[df['corner_exit']].iterrows():
        min_diff = np.inf
        closest_entrance_index = None
        for entrance_index, entrance_row in df[df.index > exit_index].iterrows():
            if entrance_row['corner_entrance']:
                diff = entrance_index - exit_index
                if diff < min_diff and diff <= 2000:
                    min_diff = diff
                    closest_entrance_index = entrance_index
                if closest_entrance_index is not None:
                    closest_pairs.append([exit_index, closest_entrance_index, min_diff, 'Straightline'])
    closest_pairs_df_straightline = pd.DataFrame(closest_pairs, columns=['Start Index', 'End Index',  'Index Difference', 'Type'])
    section_df = pd.concat([closest_pairs_df_corner, closest_pairs_df_straightline], ignore_index=True)

    data_slices = []
    for index, row in section_df.iterrows():
        start_index = row['Start Index']
        end_index = row['End Index']
        data_slice_df = global_df.loc[start_index:end_index].copy()
        data_slice_df['Type'] = row['Type']
        data_slices.append(data_slice_df)

    for i, df in enumerate(data_slices, start=1):
        chart_name_1 = f'Skating Data {i} - {df["Type"].iloc[0]} : Combined Acceleration with Boundaries Marked by Red-dots'
        chart_name_2 = f'Skating Data {i} - {df["Type"].iloc[0]} : Total Acceleration per Push'
        push_data = apply_filter_push(df,'combined acceleration',200)
        push_data['filtered_signal'] = -push_data['filtered_signal']
        push_peaks = push_detection(push_data,'filtered_signal',200)

        if not push_peaks.size == 0:
            fig = go.Figure()
            trace = go.Scatter(x=df.index, y=df['combined acceleration'], mode='lines', fill='tozeroy',name='Time Series')
            marked_trace = go.Scatter(x=df.index[push_peaks], y=df['combined acceleration'].iloc[push_peaks],
                                    mode='markers', marker=dict(size=10, color='Red', opacity=0.8), name='Marked Points')
            fig = go.Figure([trace, marked_trace])
            fig.update_layout(title= chart_name_1, xaxis_title='Time', yaxis_title='Combined Acceleration')
            st.plotly_chart(fig)

            result = []
            for j in range(len(push_peaks) - 1):
                start_index = push_peaks[j] + 1
                end_index = push_peaks[j + 1]
                slice_df = df.iloc[start_index:end_index]
                result.append(slice_df['combined acceleration'].sum())
            fig_bar = go.Figure([go.Bar(y=result, width=0.5)])
            fig_bar.update_layout(title= chart_name_2, yaxis_title='Total Acceleration from One Push', template='plotly_white')
            st.plotly_chart(fig_bar)


st.title('Body-Mounted Accelerometer Data Visualizer')
uploaded_file = st.file_uploader("Upload a CSV or TXT file", type=['csv', 'txt'])

if uploaded_file is not None:
    try:
        df = pd.read_csv(io.BytesIO(uploaded_file.getvalue()))
        st.success('File loaded successfully!')
        process_and_visualize(df)
    except Exception as e:
        st.error(f'An error occurred: {e}')

!pip install streamlit plotly==5.19.0 pandas scipy


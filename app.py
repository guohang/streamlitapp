# -*- coding: utf-8 -*-
"""Power analysis 08.25 diagnosis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aAQgs11V8Scdl5DYVIZKCG4XCT7jgZIV
"""

# Commented out IPython magic to ensure Python compatibility.
#@title センサーデータのロード { run: "auto", display-mode: "form" }

#imports and utilities
from datetime import datetime
import pandas as pd
import plotly.express as px
import numpy as np
from scipy.signal import find_peaks
import matplotlib.pyplot as plt

import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Mount Google Drive
# from google.colab import drive
# drive.mount('/content/drive')

from scipy.stats import zscore
from scipy.signal import butter, filtfilt

from ipyfilechooser import FileChooser
import ipywidgets as widgets
from IPython.display import display,clear_output
import io


#Utility Funcitons

def butter_lowpass_filter(data, cutoff, fs, order):
    """
    Apply a Butterworth low-pass filter to the input data.

    Parameters:
    - data: The input signal.
    - cutoff: The cutoff frequency of the filter.
    - fs: The sampling rate of the signal.
    - order: The order of the filter.

    Returns:
    - The filtered signal.
    """
    nyquist = 0.5 * fs
    normal_cutoff = cutoff / nyquist
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    filtered_data = filtfilt(b, a, data)
    return filtered_data

def apply_filter(data,column_name):
  # Parameters for the filter
  cutoff = 1  # Cutoff frequency in Hz
  fs = 200  # Sampling rate in Hz, an estimated value; adjust based on your data's actual sampling rate
  order = 1  # Filter order

  # Apply the filter to the z-axis data
  filtered_signal = butter_lowpass_filter(data[column_name], cutoff, fs, order)
  data['filtered_signal'] = filtered_signal

  # Plot the original and filtered signals
  # plt.figure(figsize=(15, 7))
  # plt.plot(data.index, data[column_name], label='Original Signal', alpha=0.5)
  # plt.plot(data.index, data['filtered_signal'], label='Filtered Signal', color='red', alpha=0.75)
  # plt.title('Butterworth Low-Pass Filter Application')
  # plt.xlabel('Data Index')
  # plt.ylabel(column_name)
  # plt.legend()
  # plt.show()

  return data

def corner_detection(data,column_name):

  zscore_threshold = 1

  # This is the new line to fix the error.
  # It converts the specified column to a numeric type and replaces any non-numeric
  # values with NaN, which will then be ignored in calculations.
  data[column_name] = pd.to_numeric(data[column_name], errors='coerce')

  #############
  # Normalize the 'z-axis (deg/s)' data using Min-Max normalization
  data['z-axis_normalized'] = (data[column_name] - data[column_name].min()) / (data[column_name].max() - data[column_name].min())

  # Calculate the first derivative (rate of change) of the normalized 'z-axis (deg/s)'
  data['z-axis_normalized_rate_of_change'] = data['z-axis_normalized'].diff()

  # Calculate the z-score for the normalized 'z-axis (deg/s)'
  data['z-axis_normalized_zscore'] = zscore(data['z-axis_normalized'])

  # Reapply the filtering criteria using the normalized data
  positive_potential_peaks_normalized = data[(data['z-axis_normalized_rate_of_change'].abs() > data['z-axis_normalized_rate_of_change'].quantile(0.7)) &
                                            (data['z-axis_normalized_zscore'] > zscore_threshold) &
                                            (data['z-axis_normalized'] > 0)]['z-axis_normalized']

  # Reapply the logic to remove peaks too close to each other, using normalized data
  filtered_peaks_indices_normalized = []
  last_peak_index = 0
  min_distance_between_peaks = 700

  for index in positive_potential_peaks_normalized.index:
      if index - last_peak_index >= min_distance_between_peaks:
          filtered_peaks_indices_normalized.append(index)
          last_peak_index = index

  # Extract the refined peaks based on the refined indices from normalized data
  refined_peaks_normalized = data.loc[filtered_peaks_indices_normalized, column_name]

  ###################
  # # Create an interactive line plot
  time = data.index
  gFX=data[column_name]
  # fig = px.line(data, x=time, y=[column_name], title='z-axis (deg/s)')
  # fig.add_scatter(x=time[refined_peaks_normalized.index], y=gFX[refined_peaks_normalized.index],mode='markers',marker=dict(
  #       size=10,  # Increase marker size here
  #       color='Red',  # You can customize the color
  #       opacity=0.8) )

  # # Show the plot
  # fig.show()
  return refined_peaks_normalized


def zero_crossing(df,column_name):
  # Shift the DataFrame by one row
  df['Shifted'] = df[column_name].shift(1)
  df['Value'] = df[column_name]

  # Identify zero crossings: negative to positive
  df['Neg_to_Pos'] = (df['Value'] > 0) & (df['Shifted'] < 0)

  # Identify zero crossings: positive to negative
  df['Pos_to_Neg'] = (df['Value'] < 0) & (df['Shifted'] > 0)

  # DataFrame for negative to positive zero crossings
  neg_to_pos_df = df[df['Neg_to_Pos']]

  # DataFrame for positive to negative zero crossings
  pos_to_neg_df = df[df['Pos_to_Neg']]


  # # Initialize the figure
  # fig = go.Figure()

  # # Add the main time series plot
  # fig.add_trace(go.Scatter(x=df.index, y=df['Value'], mode='lines+markers', name='Time Series',
  #                         line=dict(color='royalblue'), marker=dict(color='royalblue', size=6)))

  # # Add markers for negative to positive zero crossings
  # fig.add_trace(go.Scatter(x=df[df['Neg_to_Pos']].index, y=df[df['Neg_to_Pos']]['Value'], mode='markers', name='Neg to Pos Crossings',
  #                         marker=dict(color='green', size=12, symbol='cross')))

  # # Add markers for positive to negative zero crossings
  # fig.add_trace(go.Scatter(x=df[df['Pos_to_Neg']].index, y=df[df['Pos_to_Neg']]['Value'], mode='markers', name='Pos to Neg Crossings',
  #                         marker=dict(color='red', size=12, symbol='x')))

  # # Update layout for a better look
  # fig.update_layout(title='Time Series Plot with Zero Crossings',
  #                   xaxis_title='Index',
  #                   yaxis_title='Value',
  #                   legend_title='Legend',
  #                   template='plotly_white')

  # # Show plot
  # fig.show()

  result = pd.concat([pos_to_neg_df, neg_to_pos_df])
  result = result.sort_index()
  result.rename(columns={'Neg_to_Pos': 'corner_entrance'}, inplace=True)
  result.rename(columns={'Pos_to_Neg': 'corner_exit'}, inplace=True)

  return result


def find_entrance_exit(peaks,entrance_exit):

  df = entrance_exit
  # Define index range
  start_idx = min(peaks.index)
  end_idx = max(peaks.index)

  # Select rows within this range
  selected_df = df.loc[start_idx:end_idx]

  # Get all indices as a list
  all_indices = df.index.tolist()

  # Get indices for the selected range
  selected_indices = selected_df.index.tolist()

  # Identify the indices for rows immediately before and after the selected range
  before_after_indices = []

  for idx in selected_indices:
      idx_pos = all_indices.index(idx)
      # Append previous index if it exists
      if idx_pos > 0:
          before_after_indices.append(all_indices

# -*- coding: utf-8 -*-
"""Power analysis 08.25 diagnosis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aAQgs11V8Scdl5DYVIZKCG4XCT7jgZIV
"""

# Commented out IPython magic to ensure Python compatibility.
#@title センサーデータのロード { run: "auto", display-mode: "form" }

#imports and utilities
from datetime import datetime
import pandas as pd
import plotly.express as px
import numpy as np
from scipy.signal import find_peaks
import matplotlib.pyplot as plt

import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Mount Google Drive
# from google.colab import drive
# drive.mount('/content/drive')

from scipy.stats import zscore
from scipy.signal import butter, filtfilt

from ipyfilechooser import FileChooser
import ipywidgets as widgets
from IPython.display import display,clear_output
import io


#Utility Funcitons

def butter_lowpass_filter(data, cutoff, fs, order):
    """
    Apply a Butterworth low-pass filter to the input data.

    Parameters:
    - data: The input signal.
    - cutoff: The cutoff frequency of the filter.
    - fs: The sampling rate of the signal.
    - order: The order of the filter.

    Returns:
    - The filtered signal.
    """
    nyquist = 0.5 * fs
    normal_cutoff = cutoff / nyquist
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    filtered_data = filtfilt(b, a, data)
    return filtered_data

def apply_filter(data,column_name):
  # Parameters for the filter
  cutoff = 1  # Cutoff frequency in Hz
  fs = 200  # Sampling rate in Hz, an estimated value; adjust based on your data's actual sampling rate
  order = 1  # Filter order

  # Apply the filter to the z-axis data
  filtered_signal = butter_lowpass_filter(data[column_name], cutoff, fs, order)
  data['filtered_signal'] = filtered_signal

  # Plot the original and filtered signals
  # plt.figure(figsize=(15, 7))
  # plt.plot(data.index, data[column_name], label='Original Signal', alpha=0.5)
  # plt.plot(data.index, data['filtered_signal'], label='Filtered Signal', color='red', alpha=0.75)
  # plt.title('Butterworth Low-Pass Filter Application')
  # plt.xlabel('Data Index')
  # plt.ylabel(column_name)
  # plt.legend()
  # plt.show()

  return data

def corner_detection(data,column_name):

  zscore_threshold = 1

  # This is the new line to fix the error.
  # It converts the specified column to a numeric type and replaces any non-numeric
  # values with NaN, which will then be ignored in calculations.
  data[column_name] = pd.to_numeric(data[column_name], errors='coerce')

  #############
  # Normalize the 'z-axis (deg/s)' data using Min-Max normalization
  data['z-axis_normalized'] = (data[column_name] - data[column_name].min()) / (data[column_name].max() - data[column_name].min())

  # Calculate the first derivative (rate of change) of the normalized 'z-axis (deg/s)'
  data['z-axis_normalized_rate_of_change'] = data['z-axis_normalized'].diff()

  # Calculate the z-score for the normalized 'z-axis (deg/s)'
  data['z-axis_normalized_zscore'] = zscore(data['z-axis_normalized'])

  # Reapply the filtering criteria using the normalized data
  positive_potential_peaks_normalized = data[(data['z-axis_normalized_rate_of_change'].abs() > data['z-axis_normalized_rate_of_change'].quantile(0.7)) &
                                            (data['z-axis_normalized_zscore'] > zscore_threshold) &
                                            (data['z-axis_normalized'] > 0)]['z-axis_normalized']

  # Reapply the logic to remove peaks too close to each other, using normalized data
  filtered_peaks_indices_normalized = []
  last_peak_index = 0
  min_distance_between_peaks = 700

  for index in positive_potential_peaks_normalized.index:
      if index - last_peak_index >= min_distance_between_peaks:
          filtered_peaks_indices_normalized.append(index)
          last_peak_index = index

  # Extract the refined peaks based on the refined indices from normalized data
  refined_peaks_normalized = data.loc[filtered_peaks_indices_normalized, column_name]

  ###################
  # # Create an interactive line plot
  time = data.index
  gFX=data[column_name]
  # fig = px.line(data, x=time, y=[column_name], title='z-axis (deg/s)')
  # fig.add_scatter(x=time[refined_peaks_normalized.index], y=gFX[refined_peaks_normalized.index],mode='markers',marker=dict(
  #       size=10,  # Increase marker size here
  #       color='Red',  # You can customize the color
  #       opacity=0.8) )

  # # Show the plot
  # fig.show()
  return refined_peaks_normalized


def zero_crossing(df,column_name):
  # Shift the DataFrame by one row
  df['Shifted'] = df[column_name].shift(1)
  df['Value'] = df[column_name]

  # Identify zero crossings: negative to positive
  df['Neg_to_Pos'] = (df['Value'] > 0) & (df['Shifted'] < 0)

  # Identify zero crossings: positive to negative
  df['Pos_to_Neg'] = (df['Value'] < 0) & (df['Shifted'] > 0)

  # DataFrame for negative to positive zero crossings
  neg_to_pos_df = df[df['Neg_to_Pos']]

  # DataFrame for positive to negative zero crossings
  pos_to_neg_df = df[df['Pos_to_Neg']]


  # # Initialize the figure
  # fig = go.Figure()

  # # Add the main time series plot
  # fig.add_trace(go.Scatter(x=df.index, y=df['Value'], mode='lines+markers', name='Time Series',
  #                         line=dict(color='royalblue'), marker=dict(color='royalblue', size=6)))

  # # Add markers for negative to positive zero crossings
  # fig.add_trace(go.Scatter(x=df[df['Neg_to_Pos']].index, y=df[df['Neg_to_Pos']]['Value'], mode='markers', name='Neg to Pos Crossings',
  #                         marker=dict(color='green', size=12, symbol='cross')))

  # # Add markers for positive to negative zero crossings
  # fig.add_trace(go.Scatter(x=df[df['Pos_to_Neg']].index, y=df[df['Pos_to_Neg']]['Value'], mode='markers', name='Pos to Neg Crossings',
  #                         marker=dict(color='red', size=12, symbol='x')))

  # # Update layout for a better look
  # fig.update_layout(title='Time Series Plot with Zero Crossings',
  #                   xaxis_title='Index',
  #                   yaxis_title='Value',
  #                   legend_title='Legend',
  #                   template='plotly_white')

  # # Show plot
  # fig.show()

  result = pd.concat([pos_to_neg_df, neg_to_pos_df])
  result = result.sort_index()
  result.rename(columns={'Neg_to_Pos': 'corner_entrance'}, inplace=True)
  result.rename(columns={'Pos_to_Neg': 'corner_exit'}, inplace=True)

  return result


def find_entrance_exit(peaks,entrance_exit):

  df = entrance_exit
  # Define index range
  start_idx = min(peaks.index)
  end_idx = max(peaks.index)

  # Select rows within this range
  selected_df = df.loc[start_idx:end_idx]

  # Get all indices as a list
  all_indices = df.index.tolist()

  # Get indices for the selected range
  selected_indices = selected_df.index.tolist()

  # Identify the indices for rows immediately before and after the selected range
  before_after_indices = []

  for idx in selected_indices:
      idx_pos = all_indices.index(idx)
      # Append previous index if it exists
      if idx_pos > 0:
          before_after_indices.append(all_indices[idx_pos - 1])
      # Append current index
      before_after_indices.append(idx)
      # Append next index if it exists
      if idx_pos < len(all_indices) - 1:
          before_after_indices.append(all_indices[idx_pos + 1])

  # Ensure uniqueness and sort them to maintain the order
  final_indices = sorted(set(before_after_indices))

  # Extract these indices from the DataFrame
  final_selection = df.loc[final_indices]

  # #Remove rows which are too close
  # index_threshold = 20  # This means indices must be at least 3 units apart
  # # Calculate index differences
  # final_selection['Index_Diff'] = final_selection.index.to_series().diff()
  # # Filter rows where the index difference is too small
  # final_selection = final_selection[(final_selection['Index_Diff'] >= index_threshold) | (final_selection['Index_Diff'].isna())]

  return final_selection

def apply_filter_corner(data,column_name,cutoff):
  # Parameters for the filter
  cutoff = cutoff  # Cutoff frequency in Hz
  fs = 200  # Sampling rate in Hz, an estimated value; adjust based on your data's actual sampling rate
  order = 1  # Filter order

  # Apply the filter to the z-axis data
  filtered_signal = butter_lowpass_filter(data[column_name], cutoff, fs, order)
  result = data.copy()
  result[column_name] = filtered_signal

  # # Plot the original and filtered signals
  # plt.figure(figsize=(15, 7))
  # plt.plot(data.index, data[column_name], label='Original Signal', alpha=0.5)
  # plt.plot(result.index, result[column_name], label='Filtered Signal', color='red', alpha=0.75)
  # plt.title('Butterworth Low-Pass Filter Application')
  # plt.xlabel('Data Index')
  # plt.ylabel(column_name)
  # plt.legend()
  # plt.show()

  return result


def push_detection(data,column_name,sampling_rate):

  peaks, _ = find_peaks(data[column_name], prominence=0.5, distance=sampling_rate/4)  # Adjust 'height' and 'distance' as needed


  # fig = px.line(data, x=data.index, y=[column_name], title=column_name)
  # fig.add_scatter(x=peaks, y=data[column_name][peaks],mode='markers',marker=dict(
  #       size=10,  # Increase marker size here
  #       color='Red',  # You can customize the color
  #       opacity=0.8) )

  # # Show the plot
  # fig.show()
  return peaks


def apply_filter_push(data,column_name,sampling_rate):
  # Parameters for the filter
  cutoff = 5  # Cutoff frequency in Hz
  fs = sampling_rate  # Sampling rate in Hz, an estimated value; adjust based on your data's actual sampling rate
  order = 5  # Filter order

  # Apply the filter to the z-axis data
  filtered_signal = butter_lowpass_filter(data[column_name], cutoff, fs, order)
  data['filtered_signal'] = filtered_signal

  # # Plot the original and filtered signals
  # plt.figure(figsize=(15, 7))
  # plt.plot(data.index, data[column_name], label='Original Signal', alpha=0.5)
  # plt.plot(data.index, data['filtered_signal'], label='Filtered Signal', color='red', alpha=0.75)
  # plt.title('Butterworth Low-Pass Filter Application')
  # plt.xlabel('Data Index')
  # plt.ylabel(column_name)
  # plt.legend()
  # plt.show()

  return data

def entrance_exit_function(df_source):
  #Find corner entrance and exit
  data = apply_filter_corner(df_source.copy(),'Angle Y(°)',0.5)
  peaks = corner_detection(df_source,'Angle Y(°)')
  zero_cross = zero_crossing(data,'Angle Y(°)')
  entrance_exit = find_entrance_exit(peaks, zero_cross)


  # #plot
  # fig = go.Figure()

  # # Add the main time series plot
  # fig.add_trace(go.Scatter(x=data.index, y=data['Angle Y(°)'], mode='lines+markers', name='Time Series',
  #                         line=dict(color='royalblue'), marker=dict(color='royalblue', size=6)))

  # # Add markers for negative to positive zero crossings
  # fig.add_trace(go.Scatter(x=entrance_exit[entrance_exit['corner_entrance']].index, y=entrance_exit[entrance_exit['corner_entrance']]['Angle Y(°)'], mode='markers', name='Corner Entrance',
  #                         marker=dict(color='green', size=12, symbol='cross')))

  # # Add markers for positive to negative zero crossings
  # fig.add_trace(go.Scatter(x=entrance_exit[entrance_exit['corner_exit']].index, y=entrance_exit[entrance_exit['corner_exit']]['Angle Y(°)'], mode='markers', name='Corner Exit',
  #                         marker=dict(color='red', size=12, symbol='x')))

  # # Update layout for a better look
  # fig.update_layout(title='Time Series Plot with Zero Crossings',
  #                   xaxis_title='Index',
  #                   yaxis_title='Value',
  #                   legend_title='Legend',
  #                   template='plotly_white')

  # fig.show()

  return entrance_exit



def straight_push_index(entrance_exit):
  #Identify the index between corner exit and corner entrance
  df = entrance_exit

  # Finding indices where 'corner_exit' is True
  exit_indices = df.index[df['corner_exit']].tolist()

  # Finding indices where 'corner_entrance' is True
  entrance_indices = df.index[df['corner_entrance']].tolist()

  # Store pairs
  pairs = []

  # Loop over exit indices to find matching entrance conditions
  for i in range(len(exit_indices)-1):
      current_exit_idx = exit_indices[i]
      # Find the next occurrence where entrance is True
      for j in range(len(entrance_indices)):
          if entrance_indices[j] > current_exit_idx:
              pairs.append((current_exit_idx, entrance_indices[j]))
              break  # Stop after the first match to ensure pairs are minimal and ordered

  print("\nIndex Pairs:")
  for pair in pairs:
      print(pair)

  return pairs

def combined_frontal_acceleration(df):

  df['combined acceleration'] = (df['Acceleration Z(g)']**2+df['Acceleration Y(g)']**2+df['Acceleration X(g)']**2)**0.5
  # Assuming `data_subset` contains the subset of your data
  # Create a subplot with 3 rows
  return df


def visualization (df):
  fig = make_subplots(rows=7, cols=1, shared_xaxes=True)

  # Adding AccX(g) to the first subplot
  fig.add_trace(go.Scatter(x=df.index, y=df['Acceleration Z(g)'], name='z-axis (g)'), row=1, col=1)

  # Adding AccY(g) to the second subplot
  fig.add_trace(go.Scatter(x=df.index, y=df['Acceleration X(g)'], name='x-axis (g)', marker_color='orange'), row=2, col=1)

  # Adding AccZ(g) to the third subplot
  fig.add_trace(go.Scatter(x=df.index, y=-df['Acceleration Y(g)'], name='-y-axis (g)', marker_color='green'), row=3, col=1)

  fig.add_trace(go.Scatter(x=df.index, y=df['Angular velocity Z(°/s)'], name='z-axis (Deg/s)', marker_color='red'), row=4, col=1)

  fig.add_trace(go.Scatter(x=df.index, y=df['Angle X(°)'], name='Angle X(°)', marker_color='cyan'), row=5, col=1)
  fig.add_trace(go.Scatter(x=df.index, y=df['Angle Y(°)'], name='Angle Y(°)', marker_color='yellow'), row=6, col=1)

  fig.add_trace(go.Scatter(x=df.index, y=df['combined acceleration'], name='combined acceleration', marker_color='black'), row=7, col=1)

  # Update layout for a cleaner look
  fig.update_layout(height=900, width=700, showlegend=False)
  fig.update_xaxes(title_text="センサーデータの可視化", row=3, col=1)
  fig.update_yaxes(title_text="z-axis (g)", row=1, col=1)
  fig.update_yaxes(title_text="x-axis (g)", row=2, col=1)
  fig.update_yaxes(title_text="-y-axis (g)", row=3, col=1)
  fig.update_yaxes(title_text="z-axis (Deg/s)", row=4, col=1)
  fig.update_yaxes(title_text="Angle X(°)", row=5, col=1)
  fig.update_yaxes(title_text="Angle Y(°)", row=6, col=1)
  fig.update_yaxes(title_text="combined acceleration", row=7, col=1)
  # Show the figure
  fig.update_layout(width=1500, height=1000)
  #fig.update_layout(dragmode='drawrect')

  fig.show()
  return fig

# #######
# #User Interface Code
# fc = FileChooser('/content/drive/My Drive/')
# display(fc)
# global_df = None

# def load_data(b):
#     global global_df  # Declare the use of the global variable

#     file_path = fc.selected
#     try:
#         if file_path.endswith('.csv'):
#             global_df = pd.read_csv(file_path)
#         elif file_path.endswith('.xlsx'):
#             global_df = pd.read_excel(file_path)
#         elif file_path.endswith('.json'):
#             global_df = pd.read_json(file_path)
#         else:
#             print("Unsupported file type.")
#             return

#         print("Data loaded")  # Print the first few rows of the DataFrame

#         #Add overall acceleration
#         global_df=combined_frontal_acceleration(global_df.copy())

#     except Exception as e:
#         print(f"Error loading file: {e}")

# # Create a button widget
# load_button = widgets.Button(
#     description='Load Data',
#     button_style='info', # 'success', 'info', 'warning', 'danger' or ''
#     tooltip='Click to load data',
# )
# load_button.on_click(load_data)  # Register the function to be called on button click
# display(load_button)

# ##############

# %matplotlib notebook
global_df = pd.DataFrame()

upload = widgets.FileUpload(
    accept='.csv',  # Specify the file type you want to accept
    multiple=False,  # Set to True if you wish to upload multiple files
    description='Upload CSV'
)

display(upload)

process_button = widgets.Button(description="Process Data")

display(process_button)

def process_data(b):
    # Check if a file has been uploaded
    global global_df
    global entrance_exit
    if upload.value:
        input_file = next(iter(upload.value.values()))
        content = input_file['content']
        # Read the content into a DataFrame
        global_df = pd.read_csv(io.BytesIO(content), encoding='utf-8')
        # Reset the index to be numeric
        global_df = global_df.reset_index()
        ##
        global_df=combined_frontal_acceleration(global_df)
        entrance_exit = entrance_exit_function(global_df)
        # index_lower = entrance_exit[entrance_exit['corner_entrance'] == True].head(1).index[0]
        # index_upper = entrance_exit[entrance_exit['corner_exit'] == True].tail(1).index[0]
        # global_df = global_df.loc[index_lower:index_upper].copy().reset_index()
        print('Data loaded')

# Attach the event to the button
process_button.on_click(process_data)

"""# コーナーとストレートラインでのスケーターの脚のプッシュを特定する

1.   三角ボタンをクリックして分析を開始します
2.   コーナースケートとストレートラインスケートの個別のビジュアライゼーションが表示されます





"""

df = entrance_exit

# Initialize variables to store the closest pairs
closest_pairs = []

# Iterate over the dataframe to find the closest pairs
for entrance_index, entrance_row in df[df['corner_entrance']].iterrows():
    min_diff = np.inf
    closest_exit_index = None
    for exit_index, exit_row in df[df.index > entrance_index].iterrows():
        if exit_row['corner_exit']:
            diff = exit_index - entrance_index
            if diff < min_diff and diff <= 2000:  # Ignore pairs with index difference > 2000
                min_diff = diff
                closest_exit_index = exit_index
    if closest_exit_index is not None:
        closest_pairs.append([entrance_index, closest_exit_index, min_diff,'Corner'])

# Convert the list of lists to a DataFrame
closest_pairs_df_corner = pd.DataFrame(closest_pairs, columns=['Start Index', 'End Index', 'Index Difference','Type'])



# Initialize variables to store the closest pairs
closest_pairs = []

# Iterate over the dataframe to find the closest pairs
for exit_index, exit_row in df[df['corner_exit']].iterrows():
    min_diff = np.inf
    closest_entrance_index = None
    for entrance_index, entrance_row in df[df.index > exit_index].iterrows():
        if entrance_row['corner_entrance']:
            diff = entrance_index - exit_index
            if diff < min_diff and diff <= 2000:  # Ignore pairs with index difference > 2000
                min_diff = diff
                closest_entrance_index = entrance_index
    if closest_entrance_index is not None:
        closest_pairs.append([exit_index, closest_entrance_index, min_diff, 'Straightline'])

# Convert the list of lists to a DataFrame
closest_pairs_df_straightline = pd.DataFrame(closest_pairs, columns=['Start Index', 'End Index',  'Index Difference', 'Type'])

section_df = pd.concat([closest_pairs_df_corner, closest_pairs_df_straightline], ignore_index=True)


#Create sections from sensor data
data_slices = []

# Loop over section_df and extract data slices
for index, row in section_df.iterrows():
    start_index = row['Start Index']
    end_index = row['End Index']
    data_slice_df = global_df.loc[start_index:end_index].copy()
    data_slice_df['Type'] = row['Type']
    data_slices.append(data_slice_df)



for i, df in enumerate(data_slices, start=1):
    # Get the name for the chart
    chart_name_1 = f'Skating Data{i} - {df["Type"].iloc[0]}' + ' : Combined Acceleration with Boundaries Marked by Red-dots'
    chart_name_2 = f'Skating Data{i} - {df["Type"].iloc[0]}' + ' : Total Acceleration per Push'

    push_data = apply_filter_push(df,'combined acceleration',200)
    push_data['filtered_signal'] = -push_data['filtered_signal']
    push_peaks = push_detection(push_data,'filtered_signal',200)

    if not push_peaks.size==0:
      # Create a figure
      fig = go.Figure()

      trace = go.Scatter(x=df.index, y=df['combined acceleration'], mode='lines', fill='tozeroy',name='Time Series')


      # Create a scatter plot for the marked indices
      marked_trace = go.Scatter(x=df.index[push_peaks], y=df['combined acceleration'].iloc[push_peaks],
                                mode='markers', marker=dict(color='red', opacity=0.6, size=10),
                                name='Marked Points')

      # Create a figure
      fig = go.Figure([trace, marked_trace])

      # Update layout
      fig.update_layout(
          title= chart_name_1,
          xaxis_title='Time',
          yaxis_title='Combined Acceleration'
      )

      # Show the figure
      fig.show()


      result = []

      for i in range(len(push_peaks) - 1):
          start_index = push_peaks[i] + 1  # Starting index for slice
          end_index = push_peaks[i + 1]  # Ending index for slice (exclusive in standard Python, inclusive in pandas)
          slice_df = df.iloc[start_index:end_index]
          result.append(slice_df['combined acceleration'].sum())

      fig = go.Figure([go.Bar(y=result,width=0.5)])

      # Update layout for a better look
      fig.update_layout(
          title= chart_name_2,
          yaxis_title='Total Acceleration from One Push',
          template='plotly_white'  # Using the dark theme for the plot
      )

      # Show plot
      fig.show()
